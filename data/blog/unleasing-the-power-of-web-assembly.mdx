---
title: Unleashing the Power of WebAssembly - Practical Use Cases for a Seamless Web Experience
date: '2023-12-25'
tags: ['Front-End', 'Knowledge', 'JavaScript']
draft: false
summary: 'WebAssembly is a new technology that has the potential to change the way we build web applications. It allows us to run code written in different languages on the web at near native speed, which opens up a lot of possibilities. In this article, we will explore some practical use cases for WebAssembly and how it can be used to create a seamless web experience. ‚ö°Ô∏è'
images: []
layout: PostLayout
canonicalUrl:
---

# Introduction

WebAssembly (Wasm) has emerged as a game-changer in the realm of web development, offering unprecedented performance and portability. Originally designed to enable high-performance web applications, WebAssembly has evolved to become a versatile technology with a wide range of practical use cases. In this article, we explore the practical applications of WebAssembly and how it is revolutionizing the way we build and experience the web.

## 1. Enhancing Web Application Performance

WebAssembly allows developers to execute code at near-native speed in the browser, bridging the performance gap between web and desktop applications. By compiling high-level languages like C, C++, and Rust to Wasm, developers can achieve significant speed improvements for computationally intensive tasks, making complex applications run seamlessly in the browser.

### Use case: Matrix Multiplication

```c
// matrix_multiply.c

#include <stddef.h>

void matrix_multiply(int* a, int* b, int* result, int rows, int cols, int shared_dim) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            int sum = 0;
            for (int k = 0; k < shared_dim; ++k) {
                sum += a[i * shared_dim + k] * b[k * cols + j];
            }
            result[i * cols + j] = sum;
        }
    }
}
```

Compiling to WebAssembly üõ†Ô∏è

```bash
emcc -O3 -s WASM=1 -o matrix_multiply.wasm matrix_multiply.c
```

JavaScript Integration üöö

```javascript
// JavaScript code

fetch('matrix_multiply.wasm')
  .then((response) => response.arrayBuffer())
  .then((bytes) => WebAssembly.instantiate(bytes, {}))
  .then((results) => {
    const instance = results.instance
    const matrixA = new Int32Array([1, 2, 3, 4, 5, 6])
    const matrixB = new Int32Array([7, 8, 9, 10, 11, 12])
    const resultMatrix = new Int32Array(matrixA.length)

    instance.exports.matrix_multiply(
      matrixA.byteOffset,
      matrixB.byteOffset,
      resultMatrix.byteOffset,
      2,
      2,
      3
    )

    console.log(resultMatrix)
  })
```

In this example, the matrix multiplication is performed efficiently using WebAssembly. The `matrix_multiply` function in C is compiled to WebAssembly, and the result is obtained by calling this function from JavaScript.

## 2. Cross-Platform Compatibility üåê

WebAssembly's platform-independent nature enables developers to write code in any language, compile it to Wasm, and run it on any platform that supports Wasm execution. This cross-platform compatibility fosters code reuse and simplifies the development process, as the same Wasm module can be utilized across different environments, be it web browsers, servers, or edge devices.

### Use Case: Temperature Converter

Suppose you have a temperature conversion library written in C, and you want to make it available for different platforms, including web browsers.

C Code: temperature_converter.c

```c
#include <stdio.h>

double celsius_to_fahrenheit(double celsius) {
    return (celsius * 9 / 5) + 32;
}
```

Compiling to WebAssembly:

```bash
emcc -O3 -s WASM=1 -o temperature_converter.wasm temperature_converter.c
```

JavaScript Integration:

```javascript
// JavaScript code

fetch('temperature_converter.wasm')
  .then((response) => response.arrayBuffer())
  .then((bytes) => WebAssembly.instantiate(bytes, {}))
  .then((results) => {
    const instance = results.instance

    // Convert Celsius to Fahrenheit
    const celsiusTemperature = 25
    const fahrenheitTemperature = instance.exports.celsius_to_fahrenheit(celsiusTemperature)

    console.log(`${celsiusTemperature} Celsius is ${fahrenheitTemperature} Fahrenheit`)
  })
```

In this example, the C function `celsius_to_fahrenheit` is compiled to WebAssembly, and the temperature conversion is performed in a web browser.

## Augmenting JavaScript Applications üì¶:

WebAssembly can be seamlessly integrated with existing JavaScript applications, allowing developers to leverage its capabilities for specific performance-critical components.
This hybrid approach combines the flexibility of JavaScript with the efficiency of WebAssembly, optimizing the overall performance and user experience of web applications.

### Use case: Image Processing

You have an image processing library in C that you want to integrate with your existing JavaScript application for efficient image manipulation.

C Code: image_processing.c

```c
#include <stdint.h>

void grayscale(uint8_t* imageData, int width, int height) {
    for (int i = 0; i < width * height * 4; i += 4) {
        uint8_t average = (imageData[i] + imageData[i + 1] + imageData[i + 2]) / 3;
        imageData[i] = imageData[i + 1] = imageData[i + 2] = average;
    }
}
```

Compiling to WebAssembly:

```bash
emcc -O3 -s WASM=1 -o image_processing.wasm image_processing.c
```

JavaScript Integration:

```javascript
// JavaScript code

fetch('image_processing.wasm')
  .then((response) => response.arrayBuffer())
  .then((bytes) => WebAssembly.instantiate(bytes, {}))
  .then((results) => {
    const instance = results.instance

    // Example image data (RGBA format)
    const imageData = new Uint8Array([255, 100, 50, 255, 200, 150, 100, 255 /* ... */])

    // Apply grayscale filter
    instance.exports.grayscale(imageData.byteOffset, 2, 2)

    console.log('Image after grayscale:', imageData)
  })
```

Here, the C function grayscale is compiled to WebAssembly, allowing efficient image processing within a JavaScript application.

## Gaming in the Browser üéÆ:

WebAssembly is a game-changer for browser-based gaming, enabling the execution of complex and resource-intensive games directly in the browser without the need for plugins or extensive downloads.
Game developers can utilize WebAssembly to port existing game engines or develop new ones, providing users with a rich and immersive gaming experience on the web.

### Use Case: Simple Browser Game

Imagine you want to create a simple browser game using WebAssembly to handle game logic written in C.

C Code: game_logic.c

```c
#include <stdio.h>

int playerX = 0;
int playerY = 0;

void movePlayer(int deltaX, int deltaY) {
    playerX += deltaX;
    playerY += deltaY;
}

void getPlayerPosition(int* x, int* y) {
    *x = playerX;
    *y = playerY;
}
```

Compiling to WebAssembly:

```bash
emcc -O3 -s WASM=1 -o game_logic.wasm game_logic.c
```

JavaScript Integration:

```javascript
// JavaScript code

fetch('game_logic.wasm')
  .then((response) => response.arrayBuffer())
  .then((bytes) => WebAssembly.instantiate(bytes, {}))
  .then((results) => {
    const instance = results.instance

    // Move the player
    instance.exports.movePlayer(5, 10)

    // Get player position
    let playerX, playerY
    instance.exports.getPlayerPosition(
      (x) => {
        playerX = x
      },
      (y) => {
        playerY = y
      }
    )

    console.log(`Player Position: (${playerX}, ${playerY})`)
  })
```

In this example, the game logic written in C handles player movement, and the WebAssembly module is integrated into a simple browser game.

## Cryptocurrency and Blockchain Applications ‚õìÔ∏è:

WebAssembly is increasingly being used in the blockchain space, facilitating the execution of smart contracts on decentralized platforms.
Its speed and security features make Wasm an ideal candidate for running code on blockchain networks, ensuring efficient and secure execution of decentralized applications (DApps).

### Use Case: WebAssembly Smart Contract

Suppose you want to develop a simple smart contract for a blockchain platform using WebAssembly.

C Code: smart_contract.c

```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}
```

Compiling to WebAssembly:

```bash
emcc -O3 -s WASM=1 -o smart_contract.wasm smart_contract.c
```

JavaScript Integration (Simulating Blockchain Execution):

```javascript
// JavaScript code

fetch('smart_contract.wasm')
  .then((response) => response.arrayBuffer())
  .then((bytes) => WebAssembly.instantiate(bytes, {}))
  .then((results) => {
    const instance = results.instance

    // Simulate blockchain execution
    const resultAdd = instance.exports.add(5, 10)
    const resultMultiply = instance.exports.multiply(3, 7)

    console.log('Smart Contract Results:', resultAdd, resultMultiply)
  })
```

In this example, the C functions add and multiply represent basic smart contract logic. The WebAssembly module is used to simulate their execution within a blockchain environment.

## Machine Learning in the Browser ü§ñ:

WebAssembly is opening new frontiers for running machine learning models directly in the browser, enabling on-device inference without relying on external servers.
This approach enhances user privacy by processing sensitive data locally, providing a smoother and more responsive experience for machine learning applications.

### Use Case: TensorFlow.js Integration

Imagine you want to run a machine learning model in the browser using TensorFlow.js and WebAssembly.

TensorFlow.js Model Loading and Inference (JavaScript):

```javascript
import * as tf from '@tensorflow/tfjs'
import '@tensorflow/tfjs-backend-wasm' // WebAssembly backend

async function runModel() {
  await tf.setBackend('wasm')

  // Load the model
  const model = await tf.loadLayersModel('path/to/model.json')

  // Generate dummy input tensor
  const inputTensor = tf.tensor2d([[1, 2, 3, 4]], [1, 4])

  // Model inference
  const result = model.predict(inputTensor)

  // Display the result
  result.print()
}

runModel()
```

Ensure that you have TensorFlow.js and the WebAssembly backend installed (`npm install @tensorflow/tfjs @tensorflow/tfjs-backend-wasm)`.

This example uses TensorFlow.js with the WebAssembly backend to load a pre-trained machine learning model and perform inference in the browser.

## CAD and 3D Modeling üñ•Ô∏è:

WebAssembly's ability to handle complex calculations and graphics rendering makes it well-suited for applications like Computer-Aided Design (CAD) and 3D modeling in the browser.
Developers can deliver sophisticated design tools that run efficiently in the browser, offering users the ability to create and manipulate 3D models with ease.

### Use Case: WebAssembly-based 3D Viewer

Suppose you have a C function that generates and manipulates a 3D model, and you want to leverage WebAssembly to integrate it into a web-based CAD application.

C Code: 3DModeling.c

```
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    float x, y, z;
} Point3D;

typedef struct {
    Point3D* vertices;
    int numVertices;
} Model3D;

Model3D createCube(float sideLength) {
    Model3D cube;
    cube.numVertices = 8;
    cube.vertices = (Point3D*)malloc(cube.numVertices * sizeof(Point3D));

    // Define cube vertices
    cube.vertices[0] = (Point3D){0, 0, 0};
    cube.vertices[1] = (Point3D){sideLength, 0, 0};
    cube.vertices[2] = (Point3D){0, sideLength, 0};
    cube.vertices[3] = (Point3D){sideLength, sideLength, 0};
    cube.vertices[4] = (Point3D){0, 0, sideLength};
    cube.vertices[5] = (Point3D){sideLength, 0, sideLength};
    cube.vertices[6] = (Point3D){0, sideLength, sideLength};
    cube.vertices[7] = (Point3D){sideLength, sideLength, sideLength};

    return cube;
}

void scaleModel(Model3D* model, float scaleFactor) {
    for (int i = 0; i < model->numVertices; ++i) {
        model->vertices[i].x *= scaleFactor;
        model->vertices[i].y *= scaleFactor;
        model->vertices[i].z *= scaleFactor;
    }
}

void printModel(Model3D* model) {
    for (int i = 0; i < model->numVertices; ++i) {
        printf("Vertex %d: (%.2f, %.2f, %.2f)\n", i + 1, model->vertices[i].x, model->vertices[i].y, model->vertices[i].z);
    }
}

void freeModel(Model3D* model) {
    free(model->vertices);
    model->vertices = NULL;
    model->numVertices = 0;
}
```

Compiling to WebAssembly:

```bash
emcc -O3 -s WASM=1 -o 3DModeling.wasm 3DModeling.c
```

JavaScript Integration:

```javascript
// JavaScript code

fetch('3DModeling.wasm')
  .then((response) => response.arrayBuffer())
  .then((bytes) => WebAssembly.instantiate(bytes, {}))
  .then((results) => {
    const instance = results.instance

    // Create a cube model
    const cube = instance.exports.createCube(2.0)

    // Scale the cube model
    instance.exports.scaleModel(cube, 1.5)

    // Print the modified cube model
    instance.exports.printModel(cube)

    // Free the memory allocated for the model
    instance.exports.freeModel(cube)
  })
```

In this example, the C functions `createCube`, `scaleModel`, `printModel`, and `freeModel` represent a simple 3D modeling algorithm. The WebAssembly module is then integrated into a web application to create, scale, print, and free a cube model.

This example can serve as a foundation for more complex 3D modeling algorithms and their integration into web-based CAD applications using WebAssembly.

## Conclusion üéâ

WebAssembly has transcended its original purpose and is now a pivotal technology driving innovation across various domains. From enhancing web application performance to enabling complex tasks like gaming, machine learning, and blockchain interactions, WebAssembly has become an integral part of the modern web developer's toolkit. As we continue to explore its capabilities, the potential for groundbreaking applications and a seamless web experience is boundless. Embracing WebAssembly opens doors to a future where the web is not just a platform for content consumption but a dynamic and powerful environment for diverse applications.
